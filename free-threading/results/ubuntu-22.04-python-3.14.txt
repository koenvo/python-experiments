================================================================================
Performance Comparison: Threading vs Multiprocessing with Shared Data
================================================================================

Python version: 3.14.0 (main, Oct  7 2025, 15:35:21) [Clang 20.1.4 ]
Mode: GIL-based (traditional)

Initializing shared data (10,000,000 elements)...
Shared data initialized (~267.0 MB)

Configuration:
  - Number of workers: 10
  - Shared data size: 10,000,000 elements
  - CPU cores: 16

Key difference:
  - Threading: Data shared by reference (no copying)
  - Multiprocessing: Data serialized & copied to each process

--------------------------------------------------------------------------------
Running benchmarks...
--------------------------------------------------------------------------------

1. Sequential execution (10 chunks, one at a time):
   Time: 35.955 seconds

2. Threading (with GIL) (10 threads, shared memory):
   Time: 38.301 seconds
   Speedup: 0.94x

3. Multiprocessing (10 processes, data copied):
   Time: 7.499 seconds
   Speedup: 4.79x

================================================================================
Results Summary:
================================================================================

Approach                  Time (s)        Speedup         Efficiency
--------------------------------------------------------------------------------
Sequential                    35.955          1.00x         100.0%
Threading (with GIL)          38.301           0.94x            9.4%
Multiprocessing                7.499           4.79x           47.9%

--------------------------------------------------------------------------------
Direct comparison: Free-threading vs Multiprocessing
--------------------------------------------------------------------------------
Multiprocessing is FASTER by 410.7%
  Multiprocessing: 7.499
  Free-threading: 38.301s