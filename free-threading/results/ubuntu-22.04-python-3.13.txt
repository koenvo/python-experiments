================================================================================
Performance Comparison: Threading vs Multiprocessing with Shared Data
================================================================================

Python version: 3.13.8 (main, Oct  7 2025, 15:35:51) [Clang 20.1.4 ]
Mode: GIL-based (traditional)

Initializing shared data (10,000,000 elements)...
✓ Shared data initialized (~267.0 MB)

Configuration:
  - Number of workers: 10
  - Shared data size: 10,000,000 elements
  - CPU cores: 16

Key difference:
  - Threading: Data shared by reference (no copying)
  - Multiprocessing: Data serialized & copied to each process

--------------------------------------------------------------------------------
Running benchmarks...
--------------------------------------------------------------------------------

1. Sequential execution (10 chunks, one at a time):
   Time: 46.885 seconds

2. Threading (with GIL) (10 threads, shared memory):
   Time: 48.598 seconds
   Speedup: 0.96x

3. Multiprocessing (10 processes, data copied):
   Time: 10.625 seconds
   Speedup: 4.41x

================================================================================
Results Summary:
================================================================================

Approach                  Time (s)        Speedup         Efficiency
--------------------------------------------------------------------------------
Sequential                    46.885          1.00x         100.0%
Threading (with GIL)          48.598           0.96x            9.6%
Multiprocessing               10.625           4.41x           44.1%

--------------------------------------------------------------------------------
Direct comparison: Free-threading vs Multiprocessing
--------------------------------------------------------------------------------
✓ Multiprocessing is FASTER by 357.4%
  Multiprocessing: 10.625s
  Free-threading: 48.598s
